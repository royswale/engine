{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to vengi This is a C++ voxel game engine and its tools. It includes a voxel editor with character animation support and loading/saving into a lot of voxel volume formats. There are other tools like e.g. a thumbnailer for your filemanager and a command line tool to convert between several voxel formats. Find out more about features and status updates on my twitter profile . The project source code is located at github/mgerhardy/engine . We also provide debian and windows binaries here. Join our discord Server . If you just came here to use a voxel editor or to convert your voxel models into an obj or ply file, you should just go to the download page and check out the documentation of the tool as given in the navigation bar. If you came here as a developer, make sure to check out the dependencies and set up your development environment. The build scripts are cmake based, so make sure to have it installed and generate the project files for your desired ide. After setting up everything, make sure to check out the compilation guide. Images","title":"Welcome to vengi"},{"location":"#welcome-to-vengi","text":"This is a C++ voxel game engine and its tools. It includes a voxel editor with character animation support and loading/saving into a lot of voxel volume formats. There are other tools like e.g. a thumbnailer for your filemanager and a command line tool to convert between several voxel formats. Find out more about features and status updates on my twitter profile . The project source code is located at github/mgerhardy/engine . We also provide debian and windows binaries here. Join our discord Server . If you just came here to use a voxel editor or to convert your voxel models into an obj or ply file, you should just go to the download page and check out the documentation of the tool as given in the navigation bar. If you came here as a developer, make sure to check out the dependencies and set up your development environment. The build scripts are cmake based, so make sure to have it installed and generate the project files for your desired ide. After setting up everything, make sure to check out the compilation guide.","title":"Welcome to vengi"},{"location":"#images","text":"","title":"Images"},{"location":"AIRemoteDebugger/","text":"Remote AI Debugger This application allows you to connect to a running gameserver and inspect and change the state of every single ai controlled entity.","title":"AI development"},{"location":"AIRemoteDebugger/#remote-ai-debugger","text":"This application allows you to connect to a running gameserver and inspect and change the state of every single ai controlled entity.","title":"Remote AI Debugger"},{"location":"Animations/","text":"Animations There is a test application that is able to play all of the supported animations and to test them during development.. LUA You can write your animations in lua scripts - but keep in mind that this is of course not as fast as writing them in C++ - you should only use this during development for faster round trip times. Besides writing the animations in lua, the skeleton properties are stored in lua. Hot reloading (This is for the C++ code) For debug builds, the animations are linked into a shared object that is loaded into the AnimationSystem class. This feature is not active for release builds. If you would like to disable the hot reload support - call cmake with -DHOT_RELOAD_ANIM=0 . Besides the dynamic loading of the animation functions, we also install a watch on the dynamic library. Whenever the library is recompiled and relinked, the applications will automatically reload them and present you the latest code changes. The cvar that stores the value of the path to the library is called anim_lib . It should get filled automatically. But if not, either export the environment variable ANIM_LIB to the full path of that lib, or set the cvar anim_lib to the full path to the lib.","title":"Animations"},{"location":"Animations/#animations","text":"There is a test application that is able to play all of the supported animations and to test them during development..","title":"Animations"},{"location":"Animations/#lua","text":"You can write your animations in lua scripts - but keep in mind that this is of course not as fast as writing them in C++ - you should only use this during development for faster round trip times. Besides writing the animations in lua, the skeleton properties are stored in lua.","title":"LUA"},{"location":"Animations/#hot-reloading","text":"(This is for the C++ code) For debug builds, the animations are linked into a shared object that is loaded into the AnimationSystem class. This feature is not active for release builds. If you would like to disable the hot reload support - call cmake with -DHOT_RELOAD_ANIM=0 . Besides the dynamic loading of the animation functions, we also install a watch on the dynamic library. Whenever the library is recompiled and relinked, the applications will automatically reload them and present you the latest code changes. The cvar that stores the value of the path to the library is called anim_lib . It should get filled automatically. But if not, either export the environment variable ANIM_LIB to the full path of that lib, or set the cvar anim_lib to the full path to the lib.","title":"Hot reloading"},{"location":"Attributes/","text":"Attributes The attrib module manages containers with attributes that can be attached to any item or entity in the world. Attributes are things like speed, strength, intelligence (see the network definition for a full list). The attributes are then calculated by the different containers an entity has assigned (via equipment, or directly to the character). The absolute values are summed up, and then the percentage modifiers are added on top. If you e.g. get a buff or debuff this is just applying a container to your entity. The values are communicated to the client and some are also broadcasted to other clients that are seeing you. LUA The containers are defined in lua scripts. See the attribute files that are coming with the tests, or with the server.","title":"Attributes"},{"location":"Attributes/#attributes","text":"The attrib module manages containers with attributes that can be attached to any item or entity in the world. Attributes are things like speed, strength, intelligence (see the network definition for a full list). The attributes are then calculated by the different containers an entity has assigned (via equipment, or directly to the character). The absolute values are summed up, and then the percentage modifiers are added on top. If you e.g. get a buff or debuff this is just applying a container to your entity. The values are communicated to the client and some are also broadcasted to other clients that are seeing you.","title":"Attributes"},{"location":"Attributes/#lua","text":"The containers are defined in lua scripts. See the attribute files that are coming with the tests, or with the server.","title":"LUA"},{"location":"CHANGELOG/","text":"Changelog A more detailed changelog can be found on github . 0.0.10 (2020-XX-XX) General: Added --version and -v commandline option to show the current version of each application Fixed texture coordinate indices for multi layer obj exports Improved magicavoxel transform support for some models Fixed magicavoxel x-axis handling Support newer versions of vxm VoxEdit: Improved scene edit mode Progress on the ui conversion to dear imgui Tools: Rewrote the ai debugger 0.0.9 (2020-10-03) General: Fixed obj texcoord export: Sampling the borders of the texel now Added multi object support to obj export 0.0.8 (2020-09-30) General: Added obj and ply export support Restructured the documentation Improved font support for imgui ui Backend: Reworked ai debugging network protocol Optimized behaviour tree filters 0.0.7 (2020-09-15) General: Fixed wrong-name-for-symlinks shown Added support for writing qef files Added lua script interface to generate voxels Added stacktrace support for windows Refactored module structure (split app and core) Optimized character animations Hot reload character animation C++ source changes in debug builds Added quaternion lua support Updated external dependencies Refactored lua bindings Support Chronovox-Studio files (csm) Support Nick's Voxel Model files (nvm) Support more versions of the vxm format VoxEdit: Converted some voxel generation functions to lua Implemented new voxel generator scripts 0.0.6 (2020-08-02) General: Fixed gamma cvar usage Enable vsync by default Updated external dependencies Activated OpenCL in a few tools Added symlink support to virtual filesystem VoxEdit: Fixed loading palette lua script with material definitions Fixed error in resetting mirror axis Fixed noise generation Reduced palette widget size Fixed palette widget being invisible on some dpi scales 0.0.5 (2020-07-26) Client: Fixed movement Server: Fixed visibility check Fixed segfault while removing npcs VoxEdit: Started to add scene mode edit support (move volumes) VoxConvert: Support different palette files (cvar palette ) Support writing outside the registered application paths Allow to overwrite existing files General: Switched to qb as default volume format Improved scene graph support for Magicavoxel vox files Fixed invisible voxels for qb and qbt (Qubicle) volume format Support automatic loading different volume formats for assets Support Command&Conquer vxl files Support Ace of Spades map files (vxl) Support Qubicle exchange format (qef) Perform mesh extraction in dedicated threads for simple volume rendering Improved gizmo rendering and translation support Fixed memory leaks on shutdown Improved profiling support via tracy 0.0.4 (2020-06-07) General: Added support for writing binvox files Added support for reading kvx (Build-Engine) and kv6 (SLAB6) voxel volumes Performed some AFL hardening on voxel format code Don't execute keybindings if the console is active Added basic shader storage buffer support Reduced voxel vertex size from 16 to 8 bytes Apply checkerboard pattern to water surface Improved tracy profiling support A few highdpi fixes Server: Allow to specify the database port Fixed loading database chunks VoxEdit: Added scale console command to produce LODs VoxConvert: Added ability to merge all layers into one 0.0.3 (2020-05-17) Assets: Added music tracks Updated and added some new voxel models VoxEdit: Made some commands available to the ui Tweak thicken command Updated default tree generation ui values Save layers to all supported formats Fixed tree generation issue for some tree types Changed default reference position to be at the center bottom Reduced max supported volume size General: Print stacktraces on asserts Improved tree generation (mainly used in voxedit) Fixed a few asserts in debug mode for the microsoft stl Added debian package support Fixed a few undefined behaviour issues and integer overflows that could lead to problems Reorganized some modules to speed up compilation and linking times Improved audio support Fixed timing issues Fixed invalid GL states after deleting objects VoxConvert: Added a new tool to convert different voxel volumes between supported formats Currently supported are cub (CubeWorld), vox (MagicaVoxel), vmx (VoxEdit Sandbox), binvox and qb/qbt (Qubicle) Client: Added footstep and ambience sounds 0.0.2 (2020-05-06) VoxEdit: Static linked VC++ Runtime Extract voxels by color into own layers Updated tree and noise windows Implemented thicken console command Escape abort modifier action Added L-System panel General: Fixed binvox header parsing Improved compilation speed Fixed compile errors with locally installed glm 0.9.9 Fixed setup-documentation errors Fixed shader pipeline rebuilds if included shader files were modified Improved palm tree generator Optimized mesh extraction for the world (streaming volumes) Added new voxel models (Re-)added Tracy profiler support and removed own imgui-based implementation Fixed writing of key bindings Improved compile speed and further removed the STL from a lot of places Updated all dependencies to their latest version Server/Client: Added DBChunkPersister Built-in HTTP server to download the chunks Replaced ui for the client Voxel rendering Implemented reflection for water surfaces Apply checkerboard pattern to voxel surfaces Up-scaling effect for new voxel chunks while they pop in Optimized rendering by not using one giant vbo 0.0.1 \"Initial Release\" (2020-02-08) VoxEdit: initial release","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"A more detailed changelog can be found on github .","title":"Changelog"},{"location":"CHANGELOG/#0010-2020-xx-xx","text":"General: Added --version and -v commandline option to show the current version of each application Fixed texture coordinate indices for multi layer obj exports Improved magicavoxel transform support for some models Fixed magicavoxel x-axis handling Support newer versions of vxm VoxEdit: Improved scene edit mode Progress on the ui conversion to dear imgui Tools: Rewrote the ai debugger","title":"0.0.10 (2020-XX-XX)"},{"location":"CHANGELOG/#009-2020-10-03","text":"General: Fixed obj texcoord export: Sampling the borders of the texel now Added multi object support to obj export","title":"0.0.9 (2020-10-03)"},{"location":"CHANGELOG/#008-2020-09-30","text":"General: Added obj and ply export support Restructured the documentation Improved font support for imgui ui Backend: Reworked ai debugging network protocol Optimized behaviour tree filters","title":"0.0.8 (2020-09-30)"},{"location":"CHANGELOG/#007-2020-09-15","text":"General: Fixed wrong-name-for-symlinks shown Added support for writing qef files Added lua script interface to generate voxels Added stacktrace support for windows Refactored module structure (split app and core) Optimized character animations Hot reload character animation C++ source changes in debug builds Added quaternion lua support Updated external dependencies Refactored lua bindings Support Chronovox-Studio files (csm) Support Nick's Voxel Model files (nvm) Support more versions of the vxm format VoxEdit: Converted some voxel generation functions to lua Implemented new voxel generator scripts","title":"0.0.7 (2020-09-15)"},{"location":"CHANGELOG/#006-2020-08-02","text":"General: Fixed gamma cvar usage Enable vsync by default Updated external dependencies Activated OpenCL in a few tools Added symlink support to virtual filesystem VoxEdit: Fixed loading palette lua script with material definitions Fixed error in resetting mirror axis Fixed noise generation Reduced palette widget size Fixed palette widget being invisible on some dpi scales","title":"0.0.6 (2020-08-02)"},{"location":"CHANGELOG/#005-2020-07-26","text":"Client: Fixed movement Server: Fixed visibility check Fixed segfault while removing npcs VoxEdit: Started to add scene mode edit support (move volumes) VoxConvert: Support different palette files (cvar palette ) Support writing outside the registered application paths Allow to overwrite existing files General: Switched to qb as default volume format Improved scene graph support for Magicavoxel vox files Fixed invisible voxels for qb and qbt (Qubicle) volume format Support automatic loading different volume formats for assets Support Command&Conquer vxl files Support Ace of Spades map files (vxl) Support Qubicle exchange format (qef) Perform mesh extraction in dedicated threads for simple volume rendering Improved gizmo rendering and translation support Fixed memory leaks on shutdown Improved profiling support via tracy","title":"0.0.5 (2020-07-26)"},{"location":"CHANGELOG/#004-2020-06-07","text":"General: Added support for writing binvox files Added support for reading kvx (Build-Engine) and kv6 (SLAB6) voxel volumes Performed some AFL hardening on voxel format code Don't execute keybindings if the console is active Added basic shader storage buffer support Reduced voxel vertex size from 16 to 8 bytes Apply checkerboard pattern to water surface Improved tracy profiling support A few highdpi fixes Server: Allow to specify the database port Fixed loading database chunks VoxEdit: Added scale console command to produce LODs VoxConvert: Added ability to merge all layers into one","title":"0.0.4 (2020-06-07)"},{"location":"CHANGELOG/#003-2020-05-17","text":"Assets: Added music tracks Updated and added some new voxel models VoxEdit: Made some commands available to the ui Tweak thicken command Updated default tree generation ui values Save layers to all supported formats Fixed tree generation issue for some tree types Changed default reference position to be at the center bottom Reduced max supported volume size General: Print stacktraces on asserts Improved tree generation (mainly used in voxedit) Fixed a few asserts in debug mode for the microsoft stl Added debian package support Fixed a few undefined behaviour issues and integer overflows that could lead to problems Reorganized some modules to speed up compilation and linking times Improved audio support Fixed timing issues Fixed invalid GL states after deleting objects VoxConvert: Added a new tool to convert different voxel volumes between supported formats Currently supported are cub (CubeWorld), vox (MagicaVoxel), vmx (VoxEdit Sandbox), binvox and qb/qbt (Qubicle) Client: Added footstep and ambience sounds","title":"0.0.3 (2020-05-17)"},{"location":"CHANGELOG/#002-2020-05-06","text":"VoxEdit: Static linked VC++ Runtime Extract voxels by color into own layers Updated tree and noise windows Implemented thicken console command Escape abort modifier action Added L-System panel General: Fixed binvox header parsing Improved compilation speed Fixed compile errors with locally installed glm 0.9.9 Fixed setup-documentation errors Fixed shader pipeline rebuilds if included shader files were modified Improved palm tree generator Optimized mesh extraction for the world (streaming volumes) Added new voxel models (Re-)added Tracy profiler support and removed own imgui-based implementation Fixed writing of key bindings Improved compile speed and further removed the STL from a lot of places Updated all dependencies to their latest version Server/Client: Added DBChunkPersister Built-in HTTP server to download the chunks Replaced ui for the client Voxel rendering Implemented reflection for water surfaces Apply checkerboard pattern to voxel surfaces Up-scaling effect for new voxel chunks while they pop in Optimized rendering by not using one giant vbo","title":"0.0.2 (2020-05-06)"},{"location":"CHANGELOG/#001-initial-release-2020-02-08","text":"VoxEdit: initial release","title":"0.0.1 \"Initial Release\" (2020-02-08)"},{"location":"Compilation/","text":"Building The project should work on Linux, Windows and OSX. It should work with any ide that is either supported by cmake or has direct cmake support. Personally I'm using vscode with clangd at the moment. But also the command line with plain old make . Linux There is a Makefile wrapper around the build system. You can just run make in the project root folder. Every project has some extra CMake targets. There are e.g. voxedit-run , voxedit-debug and voxedit-perf if the needed tools were found during cmake's configure phase. That means that you can compile a single target by typing make voxedit , run it by typing make voxedit-run , debug it by typing make voxedit-debug and profile it by typing make voxedit-perf . There are also other targets for valgrind - just use the tab completion in the build folder to get a list. Windows The project should be buildable with every ide that supports cmake. QTCreator, Eclipse CDT, vscode or Visual Studio. Just install cmake, generate the project files, and open them in your ide. Mac You can generate your xcode project via cmake or build like this: mkdir build cd build cmake .. cmake --build . If you are using the cmake Makefile generator, you get the same targets as for Linux above. You can also just type make voxedit-run to compile and run only VoxEdit. Hints If you encounter any problems, it's also a good start to check out the build pipelines of the project. This is always the most up-to-date information about how-to-build-the-project that you will find. But also please don't hesitate to ask for help on our discord server.","title":"Building"},{"location":"Compilation/#building","text":"The project should work on Linux, Windows and OSX. It should work with any ide that is either supported by cmake or has direct cmake support. Personally I'm using vscode with clangd at the moment. But also the command line with plain old make .","title":"Building"},{"location":"Compilation/#linux","text":"There is a Makefile wrapper around the build system. You can just run make in the project root folder. Every project has some extra CMake targets. There are e.g. voxedit-run , voxedit-debug and voxedit-perf if the needed tools were found during cmake's configure phase. That means that you can compile a single target by typing make voxedit , run it by typing make voxedit-run , debug it by typing make voxedit-debug and profile it by typing make voxedit-perf . There are also other targets for valgrind - just use the tab completion in the build folder to get a list.","title":"Linux"},{"location":"Compilation/#windows","text":"The project should be buildable with every ide that supports cmake. QTCreator, Eclipse CDT, vscode or Visual Studio. Just install cmake, generate the project files, and open them in your ide.","title":"Windows"},{"location":"Compilation/#mac","text":"You can generate your xcode project via cmake or build like this: mkdir build cd build cmake .. cmake --build . If you are using the cmake Makefile generator, you get the same targets as for Linux above. You can also just type make voxedit-run to compile and run only VoxEdit.","title":"Mac"},{"location":"Compilation/#hints","text":"If you encounter any problems, it's also a good start to check out the build pipelines of the project. This is always the most up-to-date information about how-to-build-the-project that you will find. But also please don't hesitate to ask for help on our discord server.","title":"Hints"},{"location":"ComputeShaderTool/","text":"ComputeShaderTool This tool parses OpenCL shader files ( *.cl ) and generates C++ source files for them. Description The generator uses ComputeShaderTemplate.h.in and generates the files by doing some string replacements. There are several variables in the template file that are replaced by the generator. $includes$ $namespace$ $name$ $createkernels$ $shutdown$ $kernels$ The parser includes a preprocessor.","title":"Compute Shader integration"},{"location":"ComputeShaderTool/#computeshadertool","text":"This tool parses OpenCL shader files ( *.cl ) and generates C++ source files for them.","title":"ComputeShaderTool"},{"location":"ComputeShaderTool/#description","text":"The generator uses ComputeShaderTemplate.h.in and generates the files by doing some string replacements. There are several variables in the template file that are replaced by the generator. $includes$ $namespace$ $name$ $createkernels$ $shutdown$ $kernels$ The parser includes a preprocessor.","title":"Description"},{"location":"Configuration/","text":"Configuration Variables The engine can get configured by so called cvars (configuration variables). These variables can be modified from within the game via key bindings, in-game console, the ui or scripts. To get a list of supported cvars (they might differ from application to application), type the command cvarlist to the in-game console ( CTRL+Tab in the default binding). The variables can get their initial value from various sources. The highest order is the command line. If you specify it on the command line, every other method will not be used. If the engine finds the cvar name in your environment variables, this one will take precendence over the one the is found in the configuration file. Next is the configuration file - this one will take precendence over the default settings that are specified in the code. The environment variable can be either lower case or upper case. For example it will work if you have CL_WIDTH or cl_width exported. The lower case variant has the higher priority. Commandline ./vengi-voxvonvert -set voxformat_scale 2.0 [...] Environment export VOXFORMAT_SCALE=2.0 ./vengi-voxconvert [...] Configuration file Linux: ~/.local/share/vengi/voxconvert/voxconvert.vars Windows: C:/Users/bob/AppData/Roaming/vengi/voxconvert/voxconvert.vars Mac: /Users/bob/Library/Application Support/vengi/voxconvert/voxconvert.vars Commands To get a list of supported commands (they might differ from application to application), type the command cmdlist to the in-game console ( CTRL+Tab in the default binding). You can also get a list when doing ./vengi-app --help on the command line. Key bindings You can also modify or add key bindings to commands. Type bindlist to the console to get a list of the current active bindings (and also here: they might differ from application to application). The command bind can be used to configure keybindings on-the-fly. These bindings are saved to a file on shutdown. Logging You can either log via syslog (on unix) or to stdout (this might of course differ from platform to platform). The log level is configured by the core_loglevel variable. The lower the value, the more you see. 0 is the highest log level (trace). General To get a rough usage overview, you can start an application with --help . It will print out the commands and configuration variables with a description and hints how to modify/use them. Video settings cl_vsync : enable or disable v-sync cl_gamma : tweak the gamma value that is applied last on rendering","title":"Configuration"},{"location":"Configuration/#configuration","text":"","title":"Configuration"},{"location":"Configuration/#variables","text":"The engine can get configured by so called cvars (configuration variables). These variables can be modified from within the game via key bindings, in-game console, the ui or scripts. To get a list of supported cvars (they might differ from application to application), type the command cvarlist to the in-game console ( CTRL+Tab in the default binding). The variables can get their initial value from various sources. The highest order is the command line. If you specify it on the command line, every other method will not be used. If the engine finds the cvar name in your environment variables, this one will take precendence over the one the is found in the configuration file. Next is the configuration file - this one will take precendence over the default settings that are specified in the code. The environment variable can be either lower case or upper case. For example it will work if you have CL_WIDTH or cl_width exported. The lower case variant has the higher priority.","title":"Variables"},{"location":"Configuration/#commands","text":"To get a list of supported commands (they might differ from application to application), type the command cmdlist to the in-game console ( CTRL+Tab in the default binding). You can also get a list when doing ./vengi-app --help on the command line.","title":"Commands"},{"location":"Configuration/#key-bindings","text":"You can also modify or add key bindings to commands. Type bindlist to the console to get a list of the current active bindings (and also here: they might differ from application to application). The command bind can be used to configure keybindings on-the-fly. These bindings are saved to a file on shutdown.","title":"Key bindings"},{"location":"Configuration/#logging","text":"You can either log via syslog (on unix) or to stdout (this might of course differ from platform to platform). The log level is configured by the core_loglevel variable. The lower the value, the more you see. 0 is the highest log level (trace).","title":"Logging"},{"location":"Configuration/#general","text":"To get a rough usage overview, you can start an application with --help . It will print out the commands and configuration variables with a description and hints how to modify/use them.","title":"General"},{"location":"Configuration/#video-settings","text":"cl_vsync : enable or disable v-sync cl_gamma : tweak the gamma value that is applied last on rendering","title":"Video settings"},{"location":"Dependencies/","text":"Dependencies cmake ninja-build postgresql Libraries development headers/libs for glm lua >= 5.4 sdl2 > 2.0.4 postgresql-server-dev >= 9.5 libpq enet libuv gtest opencl (optional) libuuid mosquitto (optional) Some of these dependencies might not be available as packages in your toolchain - most of them are also bundled with the application. But local installed headers always have the higher priority. Debian apt-get install libglm-dev lua5.4 liblua5.4-dev libsdl2-dev postgresql-server-dev-all \\ libpq-dev libenet-dev opencl-c-headers \\ wayland-protocols pkg-config uuid-dev libsdl2-mixer-dev libuv1-dev If you want to run the database server locally, you have to install the postgres server package: apt-get install postgresql-10 postgresql-contrib CREATE EXTENSION pgcrypto; MacPorts port install qt5 postgresql95-server Brew brew install qt5 mosquitto libuv sdl2 libpq sdl2_mixer Windows vcpkg install sdl2 libuv libpq lua glm glslang gtest qt5 mosquitto","title":"Dependencies"},{"location":"Dependencies/#dependencies","text":"cmake ninja-build postgresql","title":"Dependencies"},{"location":"Dependencies/#libraries","text":"development headers/libs for glm lua >= 5.4 sdl2 > 2.0.4 postgresql-server-dev >= 9.5 libpq enet libuv gtest opencl (optional) libuuid mosquitto (optional) Some of these dependencies might not be available as packages in your toolchain - most of them are also bundled with the application. But local installed headers always have the higher priority.","title":"Libraries"},{"location":"Dependencies/#debian","text":"apt-get install libglm-dev lua5.4 liblua5.4-dev libsdl2-dev postgresql-server-dev-all \\ libpq-dev libenet-dev opencl-c-headers \\ wayland-protocols pkg-config uuid-dev libsdl2-mixer-dev libuv1-dev If you want to run the database server locally, you have to install the postgres server package: apt-get install postgresql-10 postgresql-contrib CREATE EXTENSION pgcrypto;","title":"Debian"},{"location":"Dependencies/#macports","text":"port install qt5 postgresql95-server","title":"MacPorts"},{"location":"Dependencies/#brew","text":"brew install qt5 mosquitto libuv sdl2 libpq sdl2_mixer","title":"Brew"},{"location":"Dependencies/#windows","text":"vcpkg install sdl2 libuv libpq lua glm glslang gtest qt5 mosquitto","title":"Windows"},{"location":"Formats/","text":"Formats It can load a lot of different formats: MagicaVoxel vox Qubicle qef, qbt and qb VoxEdit vxm binvox CubeWorld cub Build engine kvx SLAB6 kv6 Command and Conquer vxl Ace Of Spades vxl Chronovox-Studio csm Nick's Voxel Model nvm And can also save to a lot of those. Exporting to ply and obj is also supported.","title":"Formats"},{"location":"Formats/#formats","text":"It can load a lot of different formats: MagicaVoxel vox Qubicle qef, qbt and qb VoxEdit vxm binvox CubeWorld cub Build engine kvx SLAB6 kv6 Command and Conquer vxl Ace Of Spades vxl Chronovox-Studio csm Nick's Voxel Model nvm And can also save to a lot of those. Exporting to ply and obj is also supported.","title":"Formats"},{"location":"GameDesign/","text":"Game Design This is about an mmorpg in a fantasy like world. The world is an active simulation where you \"jump\" into characters (ala Avatar). You inherit the characters abilities while you are jumped in. You learn some of the abilities in your own profile and can keep the abilities to some degree when you jump out of the character again. You will also leave some of the abilities at the entity when you jump out again. The world is divided by portals that connect islands. There is a max player amount on each island - limited by the amount of characters you can jump into. Leaving an island just gives an overview of \"free\" other islands you can travel to. And again you take your newly learned abilities with you - but not all of the characters'. The entities in the island simulation have a profession where you can decide what to do with it when you jump in. There is a value that indicates whether it's still reasonable to continue with that particular profession. If the entity - for some reason - can't continue with the current job, that value decreases and the entity will try to pick another free job. Before quitting the job, the entity will report this as an impediment in the corresponding townhall as a quest - asking for help.","title":"Game Design"},{"location":"GameDesign/#game-design","text":"This is about an mmorpg in a fantasy like world. The world is an active simulation where you \"jump\" into characters (ala Avatar). You inherit the characters abilities while you are jumped in. You learn some of the abilities in your own profile and can keep the abilities to some degree when you jump out of the character again. You will also leave some of the abilities at the entity when you jump out again. The world is divided by portals that connect islands. There is a max player amount on each island - limited by the amount of characters you can jump into. Leaving an island just gives an overview of \"free\" other islands you can travel to. And again you take your newly learned abilities with you - but not all of the characters'. The entities in the island simulation have a profession where you can decide what to do with it when you jump in. There is a value that indicates whether it's still reasonable to continue with that particular profession. If the entity - for some reason - can't continue with the current job, that value decreases and the entity will try to pick another free job. Before quitting the job, the entity will report this as an impediment in the corresponding townhall as a quest - asking for help.","title":"Game Design"},{"location":"Network/","text":"Network layer The network layer is based on udp (enet) and shared between client and server. It uses flatbuffers to generate C++ classes from fbs files that defines the protocol. See the generate_protocol cmake macro on how to integrate them. Values that should be shared between client and server - for example our cooldown ids - are part of the protocol to always have them in sync with each other. Connection [client] connects [connection established] [client] sends UserConnect message [server] UserConnectHandler [server] performs auth [auth failed] => [server] sends AuthFailed message [auth successful] => [server] sends Seed [server] broadcasts to visible UserSpawn CVar replication There are cvars that are replicated to all players on a server. The flag for this is CV_REPLICATE . If the server changes a value of such a cvar, the change is automatically transfered to all connected clients. This cvar value is also initially for each new connection to ensure that the server and the client share the same values for these cvars. User related cvars that are broadcasted to other players are marked with CV_BROADCAST . These values are also submitted to any other player that can see the entity.","title":"Network"},{"location":"Network/#network-layer","text":"The network layer is based on udp (enet) and shared between client and server. It uses flatbuffers to generate C++ classes from fbs files that defines the protocol. See the generate_protocol cmake macro on how to integrate them. Values that should be shared between client and server - for example our cooldown ids - are part of the protocol to always have them in sync with each other.","title":"Network layer"},{"location":"Network/#connection","text":"[client] connects [connection established] [client] sends UserConnect message [server] UserConnectHandler [server] performs auth [auth failed] => [server] sends AuthFailed message [auth successful] => [server] sends Seed [server] broadcasts to visible UserSpawn","title":"Connection"},{"location":"Network/#cvar-replication","text":"There are cvars that are replicated to all players on a server. The flag for this is CV_REPLICATE . If the server changes a value of such a cvar, the change is automatically transfered to all connected clients. This cvar value is also initially for each new connection to ensure that the server and the client share the same values for these cvars. User related cvars that are broadcasted to other players are marked with CV_BROADCAST . These values are also submitted to any other player that can see the entity.","title":"CVar replication"},{"location":"Persistence/","text":"Persistence layer General This module manages the persistence layer and provides drivers to talk to the database. Currently the only driver implemented is for postgresql. The main class for doing database interaction is the DBHandler . In order to generate models that represent the tables, you can use the databasetool to generate the models from metadata files. A more high level class to manage updates is the PersistenceMgr . It collects dirty-marked models and performs a mass-delta-update via prepared statements. You should use this for e.g. player updates. It's always a good idea to check out the unit tests to get an idea of the functionality of those classes. DBHandler You have to create the models with the tbl file and generate C++ classes with the databasetool (see existing tables.tbl file CMake integrations. Usually you put your classes into the C++ namespace db . Once you have those models, you can use the generated getters and setters to prepare the model. This can now get send over to the DBHandler . There are methods to insert, update, count, delete or select particular entries from tables via the model values. Copying the Model class instance is no problem, it's fast. The stuff that is copied is only 32bytes at the moment. Create (and update) table _dbHandler->createOrUpdateTable(db::EventModel()); The persistence layer has automatic upgrading and downgrading support for your tables. By defining them in a .tbl file, the system is able to generate the needed ALTER statements to get to your desired state. Workflow to update a table: Edit the tbl file Run your build Run the application The table, constraint, sequence... is updated to the state that is defined in your code. This allows you to go back and forth in your commits to test things. But keep in mind that removing a column from a table can lead to data loss. Because re-adding it, doesn't remember the previous values of course. Select by condition _dbHandler->select(db::EventModel(), persistence::DBConditionOne(), [this] (db::EventModel&& model) { [...] }); Multiple search conditions const db::DBConditionTestModelEmail emailCond(\"a@b.c\"); const db::DBConditionTestModelName nameCond(\"Foo Bar\"); _dbHandler->select(db::TestModel(), persistence::DBConditionMultiple(true, {&emailCond, &nameCond})), [this] (db::TestModel&& model) { [...] }); PersistenceMgr This class is responsible to submit chunks for accumulated database updates. If you e.g. collect an item and soon after collect another one, this class will sum the items up and only generate one sql statement, instead of two. Databasetool Table descriptions for the databasetool The databasetool binary will generate model files for the table definitions given in *.tbl files. You can specify the fields, the constraints and set an operator for dealing with conflict states (more about that later). To add a new *.tbl file to a module and automatically generate code for that table definition, you have to add the following after your cmake add_library(${LIB} ${SRCS}) call: generate_db_models(${LIB} ${CMAKE_CURRENT_SOURCE_DIR}/tables.tbl ExampleModels.h) ExampleModels.h specifies a single header where all generated table models are put into. The generated models can be used with the DBHandler from the persistence module. Example If no classname is specified, the table name will be used with Model as postfix. Table user will be generated as UserModel class, if no other classname was specified All models will be put into a db namespace - even if you specify your own namespace. For more details, see the parameter description below. table <TABLENAME> { classname <STRING> (overrides the automatically determined name) namespace <STRING> (c++ namespace where the class is put into) schema <STRING> (default is public) field <FIELDNAME> { type <FIELDTYPE> (default: string) notnull (optional) length <LENGTH> (optional) operator <OPERATOR> (default: set) lowercase (optional) default <DEFAULTVALUE> (optional) } constraints { <FIELDNAME> unique <FIELDNAME> index <FIELDNAME> primarykey <FIELDNAME2> primarykey <FIELDNAME> autoincrement (<FIELD1>, <FIELD2>) unique <FIELDNAME> foreignkey <FOREIGNTABLE> <FOREIGNFIELD> } } table A definition starts with table <TABLENAME> . The body is enclosed by { and } . classname This can be used to override the auto generated class name. The auto generated class name is generated from the table name converted to UpperCamelCase. This converts a table name like my_table to MyTable or mytable to Mytable . namespace You specify a namespace in your table definition that is called mynamespace . The table is called MyTable . The resulting c++ class will live in mynamespace::db::MyTable . If you omit the namespace setting in your table definition, the class will live in db::MyTable . schema Specifies the schema name that should be used for the table. field A field describes a table column, the name, the type and so on. This block is enclosed by { and } . default The default value for the field. length Specifies the optional length of the field. notnull If this is specified, the field may not be null. operator The operator is taken into account when you execute an insert or update statement and hit a unique key violation. This can e.g. be used to increase or decrease points for particular keys. The first time you normally perform an insert - and the following times you will hit a key violation and thus perform the insert or update with the operator specified. The default operator is set . See a full list of valid operators below. Valid operators set add subtract lowercase Convert a string value to lowercase before entering it into the database. This may not be set for password types of course. type Valid field types password string text int long timestamp boolean short byte blob constraints Here you can specify foreign key constraints, auto increment values and so on. This block is enclosed by { and } . See the example above for a list of supported constraints. Other notable features Timestamps are handled in UTC. When using int or short as a field type, there is also a setter configured that accepts enums.","title":"Persistence"},{"location":"Persistence/#persistence-layer","text":"","title":"Persistence layer"},{"location":"Persistence/#general","text":"This module manages the persistence layer and provides drivers to talk to the database. Currently the only driver implemented is for postgresql. The main class for doing database interaction is the DBHandler . In order to generate models that represent the tables, you can use the databasetool to generate the models from metadata files. A more high level class to manage updates is the PersistenceMgr . It collects dirty-marked models and performs a mass-delta-update via prepared statements. You should use this for e.g. player updates. It's always a good idea to check out the unit tests to get an idea of the functionality of those classes.","title":"General"},{"location":"Persistence/#dbhandler","text":"You have to create the models with the tbl file and generate C++ classes with the databasetool (see existing tables.tbl file CMake integrations. Usually you put your classes into the C++ namespace db . Once you have those models, you can use the generated getters and setters to prepare the model. This can now get send over to the DBHandler . There are methods to insert, update, count, delete or select particular entries from tables via the model values. Copying the Model class instance is no problem, it's fast. The stuff that is copied is only 32bytes at the moment.","title":"DBHandler"},{"location":"Persistence/#persistencemgr","text":"This class is responsible to submit chunks for accumulated database updates. If you e.g. collect an item and soon after collect another one, this class will sum the items up and only generate one sql statement, instead of two.","title":"PersistenceMgr"},{"location":"Persistence/#databasetool","text":"","title":"Databasetool"},{"location":"ShaderTool/","text":"ShaderTool This tool parses GLSL shader files (mainly *.vert , *.frag , *.geom and *.comp ) and generates C++ source files for them. The cmake macros expect the shader source below the module in a shaders/ directory. set(SHADERS first second) generate_shaders(mymodulename ${SHADERS}) The shaders given in this example would be located at src/modules/mymodulename/shaders/first.* . The tool automatically detects the type of programs that should be connected in the final shader. The code is generated into the build directory in generated/shaders . Description The generator uses ShaderTemplate.h.in and UniformBufferTemplate.h.in as a base to generat the C++ source files. There are several variables in the template file that are replaced by the generator. $includes$ $namespace$ $name$ $setters$ $attributes$ $uniforms$ $uniformarrayinfo$ $shutdown$ $uniformbuffers$ The parser includes a preprocessor. You can export constants from the GLSL shader code to the generated C++ code by using $constant . Use $constant varname 42 to generate a method that returns 42 with a name getVarname Branching / Feature toggles Usually you don't have to use branching and uniforms for feature toggles. You can use cvars with the flag CV_SHADER set. If you are going to change one of these cvars, the shaders are recompiled with the value of the cvar given as preprocessor define. This means that you can do stuff like: #if cl_shadowmap == 1 [...] #else [...] #endif The #define of cl_shadowmap is done by the shader system at compile time.","title":"Shader integration"},{"location":"ShaderTool/#shadertool","text":"This tool parses GLSL shader files (mainly *.vert , *.frag , *.geom and *.comp ) and generates C++ source files for them. The cmake macros expect the shader source below the module in a shaders/ directory. set(SHADERS first second) generate_shaders(mymodulename ${SHADERS}) The shaders given in this example would be located at src/modules/mymodulename/shaders/first.* . The tool automatically detects the type of programs that should be connected in the final shader. The code is generated into the build directory in generated/shaders .","title":"ShaderTool"},{"location":"ShaderTool/#description","text":"The generator uses ShaderTemplate.h.in and UniformBufferTemplate.h.in as a base to generat the C++ source files. There are several variables in the template file that are replaced by the generator. $includes$ $namespace$ $name$ $setters$ $attributes$ $uniforms$ $uniformarrayinfo$ $shutdown$ $uniformbuffers$ The parser includes a preprocessor. You can export constants from the GLSL shader code to the generated C++ code by using $constant . Use $constant varname 42 to generate a method that returns 42 with a name getVarname","title":"Description"},{"location":"ShaderTool/#branching-feature-toggles","text":"Usually you don't have to use branching and uniforms for feature toggles. You can use cvars with the flag CV_SHADER set. If you are going to change one of these cvars, the shaders are recompiled with the value of the cvar given as preprocessor define. This means that you can do stuff like: #if cl_shadowmap == 1 [...] #else [...] #endif The #define of cl_shadowmap is done by the shader system at compile time.","title":"Branching / Feature toggles"},{"location":"TestAnimation/","text":"testanimation The test application can cycle through all animations and entity types. It helps to visualize the skeletal animation states of the entities in the game.","title":"TestAnimation"},{"location":"TestAnimation/#testanimation","text":"The test application can cycle through all animations and entity types. It helps to visualize the skeletal animation states of the entities in the game.","title":"testanimation"},{"location":"Traze/","text":"Traze This is a voxel based representation of the traze game available at traze.iteratec.de . It uses mqtt for communication. The lib that is used for this is mosquitto . This application can be used to spectate games and to play games. You can select all active games from the debug menu, select one and decide at any time to join the game by hitting the button in the debug menu. Once you press the first WASD-key to move your bike, you are joined. TODO add scoreboard menu player explosions fix voxelfont performance issues","title":"Traze"},{"location":"Traze/#traze","text":"This is a voxel based representation of the traze game available at traze.iteratec.de . It uses mqtt for communication. The lib that is used for this is mosquitto . This application can be used to spectate games and to play games. You can select all active games from the debug menu, select one and decide at any time to join the game by hitting the button in the debug menu. Once you press the first WASD-key to move your bike, you are joined.","title":"Traze"},{"location":"Traze/#todo","text":"add scoreboard menu player explosions fix voxelfont performance issues","title":"TODO"},{"location":"VisualTests/","text":"Visual Tests These tests are dedicated test applications. They are no unit tests. Unit tests are in their own module and available via make tests Run these test applications with make __directoryname__-run or by directly executing the generated binary after compiling them. testanimation Test the voxel animation module with a default character and items of the stock module. See this for more details. testimgui Test the dearimgui integration testglslgeom Test geometry shader integration testnuklear Test the nuklear imgui integration testcomputetexture3d Test the OpenCL 3d texture integration of a 3d voxel volume (rendered as 2d side view) testvoxelgpu OpenCL mesh extraction - not finished yet. testdepthbuffer Test the depth buffer integration with shadow maps and debug renderings testtexture Renders a test 2d image. testmesh Render a mesh with shadows and bones and normals. testcamera Test camera options and collisions. testvoxelfont Display a true type font as 3d voxel volume. testplane Renders a plane object. testshapebuilder testoctree Renders the octree internals. testglslcomp Uses GLSL compute shader to render a circle. testgpumc Conversion of OpenCL marching cubes taken from: https://github.com/smistad/GPU-Marching-Cubes.git testturbobadger Renders the turbobadger demo. testluaui Test the nuklear lua ui binding testoctreevisit Visit the frustum in the octree. testtemplate Just an empty template for new test applications. testtraze traze client testhttpserver A test application around the http module server for e.g. fuzzy testing purposes. testbiomes A test application that just visualizes the biomes.","title":"Visual Tests"},{"location":"VisualTests/#visual-tests","text":"These tests are dedicated test applications. They are no unit tests. Unit tests are in their own module and available via make tests Run these test applications with make __directoryname__-run or by directly executing the generated binary after compiling them.","title":"Visual Tests"},{"location":"VisualTests/#testanimation","text":"Test the voxel animation module with a default character and items of the stock module. See this for more details.","title":"testanimation"},{"location":"VisualTests/#testimgui","text":"Test the dearimgui integration","title":"testimgui"},{"location":"VisualTests/#testglslgeom","text":"Test geometry shader integration","title":"testglslgeom"},{"location":"VisualTests/#testnuklear","text":"Test the nuklear imgui integration","title":"testnuklear"},{"location":"VisualTests/#testcomputetexture3d","text":"Test the OpenCL 3d texture integration of a 3d voxel volume (rendered as 2d side view)","title":"testcomputetexture3d"},{"location":"VisualTests/#testvoxelgpu","text":"OpenCL mesh extraction - not finished yet.","title":"testvoxelgpu"},{"location":"VisualTests/#testdepthbuffer","text":"Test the depth buffer integration with shadow maps and debug renderings","title":"testdepthbuffer"},{"location":"VisualTests/#testtexture","text":"Renders a test 2d image.","title":"testtexture"},{"location":"VisualTests/#testmesh","text":"Render a mesh with shadows and bones and normals.","title":"testmesh"},{"location":"VisualTests/#testcamera","text":"Test camera options and collisions.","title":"testcamera"},{"location":"VisualTests/#testvoxelfont","text":"Display a true type font as 3d voxel volume.","title":"testvoxelfont"},{"location":"VisualTests/#testplane","text":"Renders a plane object.","title":"testplane"},{"location":"VisualTests/#testshapebuilder","text":"","title":"testshapebuilder"},{"location":"VisualTests/#testoctree","text":"Renders the octree internals.","title":"testoctree"},{"location":"VisualTests/#testglslcomp","text":"Uses GLSL compute shader to render a circle.","title":"testglslcomp"},{"location":"VisualTests/#testgpumc","text":"Conversion of OpenCL marching cubes taken from: https://github.com/smistad/GPU-Marching-Cubes.git","title":"testgpumc"},{"location":"VisualTests/#testturbobadger","text":"Renders the turbobadger demo.","title":"testturbobadger"},{"location":"VisualTests/#testluaui","text":"Test the nuklear lua ui binding","title":"testluaui"},{"location":"VisualTests/#testoctreevisit","text":"Visit the frustum in the octree.","title":"testoctreevisit"},{"location":"VisualTests/#testtemplate","text":"Just an empty template for new test applications.","title":"testtemplate"},{"location":"VisualTests/#testtraze","text":"traze client","title":"testtraze"},{"location":"VisualTests/#testhttpserver","text":"A test application around the http module server for e.g. fuzzy testing purposes.","title":"testhttpserver"},{"location":"VisualTests/#testbiomes","text":"A test application that just visualizes the biomes.","title":"testbiomes"},{"location":"mapview/Index/","text":"General","title":"MapView"},{"location":"mapview/Index/#general","text":"","title":"General"},{"location":"server/Index/","text":"Server Architecture TODO: document server architecture, world, map, ai-zone, chunk management, user handling Network TODO: document network stuff like cvar replication, protocol (flatbuffer) stuff, login, logout and so on General Hint : In order to start the server you will need to setup the postgres database. See the setup documentation for more details. After starting the server, you will get entities spawned in the world. You can use e.g. the ai remote debugger ( src/tools/rcon ) to inspect the state or use the client to connect. To specify the database that should be used use the config bars db_name , db_host , db_pw and db_user . For example: ./vengi-server -set db_host 192.168.0.1 -set db_post 5432 -db_name vengi -db_pw engine For the client connect you need a user in the database. You can create users with a server command called sv_createuser . To get a list of available commands, you can use cmdlist in the server terminal. Chunk download The chunks are persisted in the database and can be made available via cdn or any other http server. The gameserver has a built-in http server, too. If you want to use any other http server, you have to set it via sv_httpchunkurl like this: ./vengi-server -set sv_httpchunkurl http://myhostname:8080/mychunkurl ... or export the environment variable SV_HTTPCHUNKURL or add it to your config file (see setup documentation for more details). This cvar is one of those that is automatically replicated to the client. Whenever you change it, all clients will be notified about it and use the new url. The http endpoint reads several GET paramters: x , y , z : The chunk coordinates mapid You will find these values in the chunk database table. A custom chunk endpoint just would have to send the database blob with a content type of application/chunk . Docker The docker image is using apt-cacher-ng ( https://github.com/sameersbn/docker-apt-cacher-ng ) Make sure to have this running on your docker host docker run --name apt-cacher-ng --init -d --restart=always \\ --publish 3142:3142 \\ --volume /srv/docker/apt-cacher-ng:/var/cache/apt-cacher-ng \\ sameersbn/apt-cacher-ng:3.1-1","title":"Server"},{"location":"server/Index/#server","text":"","title":"Server"},{"location":"server/Index/#architecture","text":"TODO: document server architecture, world, map, ai-zone, chunk management, user handling","title":"Architecture"},{"location":"server/Index/#network","text":"TODO: document network stuff like cvar replication, protocol (flatbuffer) stuff, login, logout and so on","title":"Network"},{"location":"server/Index/#general","text":"Hint : In order to start the server you will need to setup the postgres database. See the setup documentation for more details. After starting the server, you will get entities spawned in the world. You can use e.g. the ai remote debugger ( src/tools/rcon ) to inspect the state or use the client to connect. To specify the database that should be used use the config bars db_name , db_host , db_pw and db_user . For example: ./vengi-server -set db_host 192.168.0.1 -set db_post 5432 -db_name vengi -db_pw engine For the client connect you need a user in the database. You can create users with a server command called sv_createuser . To get a list of available commands, you can use cmdlist in the server terminal.","title":"General"},{"location":"server/Index/#chunk-download","text":"The chunks are persisted in the database and can be made available via cdn or any other http server. The gameserver has a built-in http server, too. If you want to use any other http server, you have to set it via sv_httpchunkurl like this: ./vengi-server -set sv_httpchunkurl http://myhostname:8080/mychunkurl ... or export the environment variable SV_HTTPCHUNKURL or add it to your config file (see setup documentation for more details). This cvar is one of those that is automatically replicated to the client. Whenever you change it, all clients will be notified about it and use the new url. The http endpoint reads several GET paramters: x , y , z : The chunk coordinates mapid You will find these values in the chunk database table. A custom chunk endpoint just would have to send the database blob with a content type of application/chunk .","title":"Chunk download"},{"location":"server/Index/#docker","text":"The docker image is using apt-cacher-ng ( https://github.com/sameersbn/docker-apt-cacher-ng ) Make sure to have this running on your docker host docker run --name apt-cacher-ng --init -d --restart=always \\ --publish 3142:3142 \\ --volume /srv/docker/apt-cacher-ng:/var/cache/apt-cacher-ng \\ sameersbn/apt-cacher-ng:3.1-1","title":"Docker"},{"location":"server/Setup/","text":"Setup PostgreSQL first sudo as postgres default superuser 'postgres' on bash sudo -i -u postgres adding an new new user by typing createuser -s vengi create a new database createdb vengi now start postgres and add password for these user psql write this statement ALTER USER vengi WITH PASSWORD 'engine'; For the tests you need a different database called enginetest . You can also use other user/password combinations by setting some cvars: db_name db_host db_pw db_user See the configuration documentation for more details.","title":"Setup"},{"location":"server/Setup/#setup","text":"","title":"Setup"},{"location":"server/Setup/#postgresql","text":"first sudo as postgres default superuser 'postgres' on bash sudo -i -u postgres adding an new new user by typing createuser -s vengi create a new database createdb vengi now start postgres and add password for these user psql write this statement ALTER USER vengi WITH PASSWORD 'engine'; For the tests you need a different database called enginetest . You can also use other user/password combinations by setting some cvars: db_name db_host db_pw db_user See the configuration documentation for more details.","title":"PostgreSQL"},{"location":"thumbnailer/Index/","text":"General Create thumbnailer images of all supported voxel formats. In combination with a mimetype definition and a .thumbnailer definition file that must be installed in /usr/share/mime/packages and /usr/share/thumbnailer this will e.g. create small preview images for the supported voxel formats . It works for any file manager that supports .thumbnailer entries, including Nautilus, Thunar (when tumbler is installed), Nemo, Caja, and PCManFM. Example This allows you to create the thumbnails manually. for i in $(find $HOME/dev/engine -name \"*.vox\" -or -name \"*.cub\" -or -name \"*.qbt\" -or -name \"*.qb\" -or -name \"*.vxl\" -or -name \"*.vxm\"); do fullpath=$(readlink -f $i) md5=$(echo -n \"file://$fullpath\" | md5sum -z | awk ' { print $1.\".png\" }') vengi-thumbnailer -s 128 $i $HOME/.cache/thumbnails/large/$md5 done","title":"Thumbnailer"},{"location":"thumbnailer/Index/#general","text":"Create thumbnailer images of all supported voxel formats. In combination with a mimetype definition and a .thumbnailer definition file that must be installed in /usr/share/mime/packages and /usr/share/thumbnailer this will e.g. create small preview images for the supported voxel formats . It works for any file manager that supports .thumbnailer entries, including Nautilus, Thunar (when tumbler is installed), Nemo, Caja, and PCManFM.","title":"General"},{"location":"thumbnailer/Index/#example","text":"This allows you to create the thumbnails manually. for i in $(find $HOME/dev/engine -name \"*.vox\" -or -name \"*.cub\" -or -name \"*.qbt\" -or -name \"*.qb\" -or -name \"*.vxl\" -or -name \"*.vxm\"); do fullpath=$(readlink -f $i) md5=$(echo -n \"file://$fullpath\" | md5sum -z | awk ' { print $1.\".png\" }') vengi-thumbnailer -s 128 $i $HOME/.cache/thumbnails/large/$md5 done","title":"Example"},{"location":"voxconvert/Index/","text":"General Convert voxel volume formats between each other or export to obj or ply. Supported voxel formats Usage ./vengi-voxconvert --merge --scale infile outfile --merge : will merge a multi layer volume (like vox, qb or qbt) into a single volume of the target file --scale : perform lod conversion of the input volume (50% scale per call) Just type vengi-voxconvert to get a full list of commands and options. Using a different target palette is also possible by setting the palette config var. ./vengi-voxconvert -set palette /path/to/palette.png infile outfile The palette file has to be in the dimensions 1x256. It is also possible to just provide the basename of the palette. This is e.g. nippon . The tool will then try to look up the file palette-nippon.png in the file search paths. You can convert to a different palette with this command. The closest possible color will be chosen for each color from the source file palette to the specified palette. Generate Level of detail (LOD) volumes Generate a lod scaled by 50% from the input model. ./vengi-voxconvert -s infile.vox lod1.vox Convert volume to mesh You can export your volume model into a obj or ply. ./vengi-voxconvert infile.vox outfile.obj Cvars to control the meshing: voxformat_ambientocclusion : Don't export extra quads for ambient occlusion voxels voxformat_mergequads : Merge similar quads to optimize the mesh voxformat_reusevertices : Reuse vertices or always create new ones voxformat_scale : Scale the vertices by the given factor voxformat_quads : Export to quads voxformat_withcolor : Export vertex colors voxformat_withtexcoords : Export texture coordinates See ./vengi-voxconvert --help for details. Batch convert To convert a complete directory of e.g. *.vox to *.obj files, you can use e.g. the bash like this: for i in *.vox; do vengi-voxconvert $i ${i%.vox}.obj; done","title":"VoxConvert"},{"location":"voxconvert/Index/#general","text":"Convert voxel volume formats between each other or export to obj or ply. Supported voxel formats","title":"General"},{"location":"voxconvert/Index/#usage","text":"./vengi-voxconvert --merge --scale infile outfile --merge : will merge a multi layer volume (like vox, qb or qbt) into a single volume of the target file --scale : perform lod conversion of the input volume (50% scale per call) Just type vengi-voxconvert to get a full list of commands and options. Using a different target palette is also possible by setting the palette config var. ./vengi-voxconvert -set palette /path/to/palette.png infile outfile The palette file has to be in the dimensions 1x256. It is also possible to just provide the basename of the palette. This is e.g. nippon . The tool will then try to look up the file palette-nippon.png in the file search paths. You can convert to a different palette with this command. The closest possible color will be chosen for each color from the source file palette to the specified palette.","title":"Usage"},{"location":"voxconvert/Index/#generate-level-of-detail-lod-volumes","text":"Generate a lod scaled by 50% from the input model. ./vengi-voxconvert -s infile.vox lod1.vox","title":"Generate Level of detail (LOD) volumes"},{"location":"voxconvert/Index/#convert-volume-to-mesh","text":"You can export your volume model into a obj or ply. ./vengi-voxconvert infile.vox outfile.obj Cvars to control the meshing: voxformat_ambientocclusion : Don't export extra quads for ambient occlusion voxels voxformat_mergequads : Merge similar quads to optimize the mesh voxformat_reusevertices : Reuse vertices or always create new ones voxformat_scale : Scale the vertices by the given factor voxformat_quads : Export to quads voxformat_withcolor : Export vertex colors voxformat_withtexcoords : Export texture coordinates See ./vengi-voxconvert --help for details.","title":"Convert volume to mesh"},{"location":"voxconvert/Index/#batch-convert","text":"To convert a complete directory of e.g. *.vox to *.obj files, you can use e.g. the bash like this: for i in *.vox; do vengi-voxconvert $i ${i%.vox}.obj; done","title":"Batch convert"},{"location":"voxedit/Index/","text":"General This is an opensource, cross platform voxel volume editor. You can load and save a lot of different voxel formats . Features Auto-saving Console to script your modeling (CTRL+TAB cmdlist) LUA scripting api Key bindings via cfg file Four viewport mode Grid resolution Layer support Mirror mode Auto cropping volumes Auto generate content like trees or noise volumes Import heightmaps Undo/Redo Custom color palettes Reference positions to rotate around or create auto-generated structures at Viewport screenshots Modelling with the left and right mouse buttons Modelling without the mouse - just via shortcuts and keyboard Layer animation support Skeletal character animation support Custom key bindings Show commands of actions (to configure your own key bindings) Rotate around reference position or center of volume Import bitmaps as plane Copy/Cut/Paste - paste to cursor or reference position Exporting single layers into meshes Generate level of details (LOD) volumes Controls Placing voxels via left mouse button or SHIFT+[CTRL+]Cursors Deleting voxels via right mouse button Rotating viewport via middle mouse button or holding alt and moving the mouse Holding the left or right mouse buttons spans an AABB to perform the action in Using the keybinding for +actionexecute (v) command allows you to also span an AABB with the cursor keys (resp. the keys that are bound to the +movecursor[direction] commands). Enter places the reference position at the current cursor position SHIFT+Tab opens the console (type cmdlist and cvarlist ) Palette The editor is built around a palette of 256 colors. Custom palettes are supported. The images should have a 1x256 pixel dimension. In order to use some of the feature for procedurally generated content, you also have to define your material types with a lua script. See the existing palette lua script as a reference.","title":"General"},{"location":"voxedit/Index/#general","text":"This is an opensource, cross platform voxel volume editor. You can load and save a lot of different voxel formats .","title":"General"},{"location":"voxedit/Index/#features","text":"Auto-saving Console to script your modeling (CTRL+TAB cmdlist) LUA scripting api Key bindings via cfg file Four viewport mode Grid resolution Layer support Mirror mode Auto cropping volumes Auto generate content like trees or noise volumes Import heightmaps Undo/Redo Custom color palettes Reference positions to rotate around or create auto-generated structures at Viewport screenshots Modelling with the left and right mouse buttons Modelling without the mouse - just via shortcuts and keyboard Layer animation support Skeletal character animation support Custom key bindings Show commands of actions (to configure your own key bindings) Rotate around reference position or center of volume Import bitmaps as plane Copy/Cut/Paste - paste to cursor or reference position Exporting single layers into meshes Generate level of details (LOD) volumes","title":"Features"},{"location":"voxedit/Index/#controls","text":"Placing voxels via left mouse button or SHIFT+[CTRL+]Cursors Deleting voxels via right mouse button Rotating viewport via middle mouse button or holding alt and moving the mouse Holding the left or right mouse buttons spans an AABB to perform the action in Using the keybinding for +actionexecute (v) command allows you to also span an AABB with the cursor keys (resp. the keys that are bound to the +movecursor[direction] commands). Enter places the reference position at the current cursor position SHIFT+Tab opens the console (type cmdlist and cvarlist )","title":"Controls"},{"location":"voxedit/Index/#palette","text":"The editor is built around a palette of 256 colors. Custom palettes are supported. The images should have a 1x256 pixel dimension. In order to use some of the feature for procedurally generated content, you also have to define your material types with a lua script. See the existing palette lua script as a reference.","title":"Palette"},{"location":"voxedit/LUAScript/","text":"Scripting api There is a console command (called xs ) in voxedit to execute lua scripts for generating voxels. This command expects the lua script filename ( .lua can be omitted) and the additional arguments for the main() method. Calling xs <script> help will print the supported arguments for the given script. There are two functions in each script. One is called arguments and one main . arguments returns a list of parameters for the main function. The default parameters for main are volume , region and color . color is the palette index starting from 0 . Example without parameters function main(volume, region, color) local mins = region:mins() local maxs = region:maxs() for x = mins.x, maxs.x do for y = mins.y, maxs.y do for z = mins.z, maxs.z do volume:setVoxel(x, y, z, color) end end end end Execute this via console xs scriptfile Example with one parameter function arguments() return { { name = 'n', desc = 'height level delta', type = 'int', default = '2' } } end function main(volume, region, color, n) [...] end Execute this via console xs scriptfile 1 where 1 will be the value of n . Omitting the 1 will add the default value from the argument list. LayerManager layerMgr lets you access different layers or create new ones. The functions are: new(name, visible, region) : Creates a new layer with the given name , the visible boolean, and the given size and position according to the region . get([layerId]) : Returns the layer for the given layerId - if the layerId is not given, it will return the current active layer. Which by default is the layer for the volume the script is currently executed for. Layer name() : Returns the current name of the layer. volume() : Gives you access to the volume of the layer. Color palette has several methods to work with colors. E.g. to find a closest possible match for the given palette index. The functions are: color(paletteIndex) : Pushes the vec4 of the color behind the palette index ( 0-255 ) as float values between 0.0 and 1.0 . colors() : Returns the palette RGBA colors as vec4 values. match(r, g, b) : Returns the closest possible palette color match for the given RGB ( 0-255 ) color. The returned palette index is in the range 0-255 . This value can then be used for the setVoxel method. similar(paletteindex, [coloramount]) : Return a table with similar colors given by their palette index. Region mins() : The lower boundary of the region (inclusive). maxs() : The upper boundary of the region (inclusive). setMins(mins) : The lower boundary of the region - given as ivec3 . setMaxs(maxs) : The upper boundary of the region - given as ivec3 . x() : The lower x boundary of the region. y() : The lower y boundary of the region. z() : The lower z bounary of the region. width() : The width of the region measured in voxels. height() : The height of the region measured in voxels. depth() : The depth of the region measured in voxels. Volume voxel(x, y, z) : Returns the palette index of the voxel at the given position in the volume [0-255] . Or -1 if there is no voxel. region() : Return the region of the volume. setVoxel(x, y, z, color) : Set the given color at the given coordinates in the volume. color must be in the range [0-255] . Vectors Available vector types are vec2 , vec3 , vec4 and their integer types ivec2 , ivec3 , ivec4 . local v1 = ivec3.new(1, 1, 1) There are 3 possible components for this vector. You can also call ivec3.new(1) to fill all three values with a one. Or call it like this: ivec3.new(1, 2) to create a vector with the three components of 1, 2, 2 . Other y going upwards. You have access to the cvar and cmd lua bindings, too. This means that you can access any cvar value or execute any command like layeradd or layermerge to modify the whole scene. cmd.execute(\"echo test\") var.int(\"cl_gamma\") To get a full list of commands and cvars use the console command cmdlist and cvarlist . Available scripts noise.lua Generates perlin noise with the frequency and amplitude as parameters with the current selected color. xs noise.lua 0.3 1.0 cover.lua Generates a new voxel on top of others with the current selected color and the specified height. xs cover.lua 1 pyramid.lua Generates a pyramid with the current selected color and with each level being 3 voxels high. xs pyramid.lua 3 thicken.lua Thickens the voxel - take 1 voxel and convert to 8 voxels. xs thicken.lua 1 grass.lua Generate grass on top of voxels. xs grass.lua","title":"Scripting api"},{"location":"voxedit/LUAScript/#scripting-api","text":"There is a console command (called xs ) in voxedit to execute lua scripts for generating voxels. This command expects the lua script filename ( .lua can be omitted) and the additional arguments for the main() method. Calling xs <script> help will print the supported arguments for the given script. There are two functions in each script. One is called arguments and one main . arguments returns a list of parameters for the main function. The default parameters for main are volume , region and color . color is the palette index starting from 0 .","title":"Scripting api"},{"location":"voxedit/LUAScript/#example-without-parameters","text":"function main(volume, region, color) local mins = region:mins() local maxs = region:maxs() for x = mins.x, maxs.x do for y = mins.y, maxs.y do for z = mins.z, maxs.z do volume:setVoxel(x, y, z, color) end end end end Execute this via console xs scriptfile","title":"Example without parameters"},{"location":"voxedit/LUAScript/#example-with-one-parameter","text":"function arguments() return { { name = 'n', desc = 'height level delta', type = 'int', default = '2' } } end function main(volume, region, color, n) [...] end Execute this via console xs scriptfile 1 where 1 will be the value of n . Omitting the 1 will add the default value from the argument list.","title":"Example with one parameter"},{"location":"voxedit/LUAScript/#layermanager","text":"layerMgr lets you access different layers or create new ones. The functions are: new(name, visible, region) : Creates a new layer with the given name , the visible boolean, and the given size and position according to the region . get([layerId]) : Returns the layer for the given layerId - if the layerId is not given, it will return the current active layer. Which by default is the layer for the volume the script is currently executed for.","title":"LayerManager"},{"location":"voxedit/LUAScript/#layer","text":"name() : Returns the current name of the layer. volume() : Gives you access to the volume of the layer.","title":"Layer"},{"location":"voxedit/LUAScript/#color","text":"palette has several methods to work with colors. E.g. to find a closest possible match for the given palette index. The functions are: color(paletteIndex) : Pushes the vec4 of the color behind the palette index ( 0-255 ) as float values between 0.0 and 1.0 . colors() : Returns the palette RGBA colors as vec4 values. match(r, g, b) : Returns the closest possible palette color match for the given RGB ( 0-255 ) color. The returned palette index is in the range 0-255 . This value can then be used for the setVoxel method. similar(paletteindex, [coloramount]) : Return a table with similar colors given by their palette index.","title":"Color"},{"location":"voxedit/LUAScript/#region","text":"mins() : The lower boundary of the region (inclusive). maxs() : The upper boundary of the region (inclusive). setMins(mins) : The lower boundary of the region - given as ivec3 . setMaxs(maxs) : The upper boundary of the region - given as ivec3 . x() : The lower x boundary of the region. y() : The lower y boundary of the region. z() : The lower z bounary of the region. width() : The width of the region measured in voxels. height() : The height of the region measured in voxels. depth() : The depth of the region measured in voxels.","title":"Region"},{"location":"voxedit/LUAScript/#volume","text":"voxel(x, y, z) : Returns the palette index of the voxel at the given position in the volume [0-255] . Or -1 if there is no voxel. region() : Return the region of the volume. setVoxel(x, y, z, color) : Set the given color at the given coordinates in the volume. color must be in the range [0-255] .","title":"Volume"},{"location":"voxedit/LUAScript/#vectors","text":"Available vector types are vec2 , vec3 , vec4 and their integer types ivec2 , ivec3 , ivec4 . local v1 = ivec3.new(1, 1, 1) There are 3 possible components for this vector. You can also call ivec3.new(1) to fill all three values with a one. Or call it like this: ivec3.new(1, 2) to create a vector with the three components of 1, 2, 2 .","title":"Vectors"},{"location":"voxedit/LUAScript/#other","text":"y going upwards. You have access to the cvar and cmd lua bindings, too. This means that you can access any cvar value or execute any command like layeradd or layermerge to modify the whole scene. cmd.execute(\"echo test\") var.int(\"cl_gamma\") To get a full list of commands and cvars use the console command cmdlist and cvarlist .","title":"Other"},{"location":"voxedit/LUAScript/#available-scripts","text":"","title":"Available scripts"},{"location":"voxedit/LUAScript/#noiselua","text":"Generates perlin noise with the frequency and amplitude as parameters with the current selected color. xs noise.lua 0.3 1.0","title":"noise.lua"},{"location":"voxedit/LUAScript/#coverlua","text":"Generates a new voxel on top of others with the current selected color and the specified height. xs cover.lua 1","title":"cover.lua"},{"location":"voxedit/LUAScript/#pyramidlua","text":"Generates a pyramid with the current selected color and with each level being 3 voxels high. xs pyramid.lua 3","title":"pyramid.lua"},{"location":"voxedit/LUAScript/#thickenlua","text":"Thickens the voxel - take 1 voxel and convert to 8 voxels. xs thicken.lua 1","title":"thicken.lua"},{"location":"voxedit/LUAScript/#grasslua","text":"Generate grass on top of voxels. xs grass.lua","title":"grass.lua"}]}